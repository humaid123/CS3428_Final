
We use
mongoose for the database
bcrypt to encrypt passwords


Steps
We create a mongoose model  <= a model is an object which allows you to manipulate the schema in the database. Mongoose in an object oriented database => even your records have methods
before saving any new object, we call bcrypt.hash() to store a hashed password
we then add the required methods to our model

we then use passport to CREATE MIDDLEWARES.
passport create middlewares which you can pass to secure your routes....
to create a middleware in passport, use:
//local strategy
const passport = require('passport')
const localStrategy = require('passport-local').Strategy;
const Model = require('./Model');
passport.use(
    '<middleware name>',
    new LocalStrategy({
	usernameField: '<the field you use as your username>', 
	passwordField: '<the filed you use for your password>'}, 
	<additional callback after you saved that can use (username, password, done) => {}>)
);

// we create TWO such middleware, one for login and one for creating an account
// we create JWT middleware for the other routes with:
const JWTstrategy = require('passport-jwt').Strategy;
const ExtractJWT = require('passport-jwt').ExtractJwt;

passport.use(
  new JWTstrategy(
    {
      secretOrKey: 'TOP_SECRET',
      jwtFromRequest: ExtractJWT.fromUrlQueryParameter('secret_token')
    },
    async (token, done) => {
      try {
        return done(null, token.user);
      } catch (error) {
        done(error);
      }
    }
  )
); 

// we then create the login and create account routes in express with a router
// we then create the secure routes which uses the passport middleware



passport library
====================================
passport.authenticate(<strategy name>, <verify callback>)
==========================================================
passport.authenticate provides you a middleware that you can tag along in express.

passport.authenticate("local") and passport.authenticate("jwt") are enough to provide secure routes. => they add the necessary middleware
Both of them allow the use of a callback RIGHT AFTER AUTHENTICATION
the callback is as such
(err, user, info) {}
// err is set if there is an error on authentication
// user is set to false if authentication failed
// info contains the info depending on the strategy used
So, passport.authenticate looks like:
passport.authenticate(<strategy>, (err, user, info) => {
	//err if exception
	// user is a boolean which says if authenticated. false if wrong details
	// info is a json with data depending on the strategy used.
})

passport.use(<the name of the strategy you are creating>, new <Strategy>(<authentication callback>))
===============================================================================
passport.use() is used to configure/create your strategies...

you pass in one of the objects provided by .Strategy =>
let localStrategy = require("passport-local").Strategy;
let JWTStrategy = require("passport-jwt").Strategy;

// In passport, a strategy is a way to authenticate requests.
// a strategy is using a porvided username and a password to verify and/or adding OAth, OpenID
// Before calling 'authenticate', you need to tell passport how to configure each strategy

Each strategy is AN OBJECT which you instantiate with a callback.
That callback called a 'VERIFY CALLBACK' takes a username, password and done() to run

When passport authenticates, it parses the credntial obtained from the request and then passes it through the given callback
if credentials are right => you need to find the user in your database and call done(null, user)
if the credentials are not right => you use done(null, false)
	if it is wrong, you can pass an additional json with the info you want to pass like 
		done(null, false, {message: 'Incorrect passport'})
if there is an error => you can use done(err);

How to use passport
============================================
you require passport,
you require the strategy you want
you call passport.use(new <Strategy>(<verifyCallback>));
	For local, the verifycallback takes a username, a password and a done callback.
		You use that username and that password to authenticate the user,
		if you find the user, you authenticate him by passing the callback done(null, user)
		if you don't find the user, you call, done(null, false, {message: 'message'})
		if there is an error, you call done(err)
the strategy that are available for you are:
local <= for when you want to authenticate somone in your network <= passport-local
jwt <= when you want to use JSON web token <= passport-jwt
passport.use('local', (username, password, done) => {})

You can also name your configuration with
passport.use('<name>', new <Strategy>(<callback>));

Note that the names, 'local' and 'jwt' are already taken.
You can create different passport strategies for login and sign up with
passport.use('login', new <Strategy>((username, password, done) => {}))
passport.use('sign up', new <Strategy>((username) => {}))

Then on your different routes, you use passport.authenticate(<name>, (<verify callback>));
for example if you want to use your login strategy you write:
app.use('<path>', passport.authenticate('login', (err, user, info) => ), (req, res) => {});



We use local to create an account and to login
When a user is logged in, we give them a token.
Any time, they want to access the database, they can use that token to get the value.
The tokens never expire, once you get a token, you can always come back and use the database
I am just going to expire the token after 5hrs.